---
title: "Projektaufgaben Block 4"
author: "Carlo Michaelis, 573479; David Hinrichs, 572347; Lukas Ruff, 572521"
date: "31 Januar 2017"
output:
  pdf_document:
    fig_caption: yes
    keep_tex: yes
    latex_engine: pdflatex
    number_sections: yes
  html_document: default
header-includes:
- \usepackage{amsthm}
- \usepackage{amssymb}
- \usepackage{amsmath}
- \DeclareMathOperator*{\argmin}{argmin}
- \usepackage{MnSymbol}
- \usepackage{bbm}
- \usepackage{subfig}
- \usepackage{theoremref}
- \newtheorem{satz}{Satz}
- \newcommand{\E}{\mathbb{E}}
- \newcommand{\Var}{\text{Var}}
- \newcommand{\tr}{\text{tr}}
fontsize: 10pt
documentclass: article
---

```{r setup, include=FALSE}
# Load libraries
# shit's getting serious
library('ggplot2')
```

# Markovketten zur Modellierung von Krebswachstum

```{r Read data}
# Read data
P <- as.matrix(read.csv("data/lungcancer.csv"))
nStates <- dim(P)[1]

# Sanity check
apply(P, 1, sum)
```

```{r Mean number of steps for cancer to reach position (Method 1)}
# Method 1
fnMCMeanSteps1 <- function(x, mu, P, tailProb = 0.01){
  # This function computes the mean number of steps needed to reach state x for
  # a Markov chain defined with initial distribution mu and transition matrix P.
  # 
  # Args:
  #   x:        Target state
  #   mu:       Initial distribution
  #   P:        Transition matrix
  #   tailProb: Tail probability to control approximation
  #   
  # Returns:
  #   Expected number of steps to reach state x for the first time
  
  # Step 0
  cumProbs <- mu[x]
  mean <- mu[x] * 0  # symbolic initialization
  
  # Step 1
  tempProb <- sum(mu[-x] * P[-x, x])
  cumProbs <- cumProbs + tempProb
  mean <- mean + tempProb * 1
  
  # Further steps
  PTilde <- diag(length(mu) - 1)  # initialize PTilde
  k <- 2
  
  while (1-cumProbs >= tailProb) {
    PTilde <- PTilde %*% P[-x, -x]  # Update PTilde
    tempProb <- mu[-x] %*% PTilde %*% P[-x, x]  # Get prob. of hitting time k
    cumProbs <- cumProbs + tempProb  # cumulate probability mass
    mean <- mean + tempProb * k  # update mean
    k <- k+1
  }
  
  # Return mean
  return(as.double(mean))
}
```

```{r Test Method 1}
# Define initial distribution (always begin in state 23 (Lung))
mu <- rep(0, nStates)
mu[23] <- 1

# Expected steps to reach certain position
meanStepsBladder <- fnMCMeanSteps1(5, mu, P, tailProb = 10^-5)
meanStepsBrain <- fnMCMeanSteps1(7, mu, P, tailProb = 10^-5)
meanStepsHeart <- fnMCMeanSteps1(17, mu, P, tailProb = 10^-5)
```

```{r Mean number of steps for cancer to reach position (Method 2)}
# Method 2
fnMCMeanSteps2 <- function(x, mu, P, T = 1000){
  # This function computes the mean number of steps needed to reach state x for
  # a Markov chain defined with initial distribution mu and transition matrix P.
  # This method approximates the mean using 10'000 Markov chain simulations with
  # a maximum of T steps per simulation.
  # 
  # Args:
  #   x:  Target state
  #   mu: Initial distribution
  #   P:  Transition matrix
  #   T:  Maximum length of Markov chain
  #   
  # Returns:
  #   Expected number of steps to reach state x for the first time
  
  # Number of states and simulations
  nStates <- length(mu)
  nSim <- 10^4
  
  # Initialize matrix for markov chains
  matSteps <- matrix(nrow = nSim, ncol = T)
  
  # Sample initial state with mu
  matSteps[, 1] <- sample(1:nStates, nSim, replace = TRUE, prob = mu)
  
  # Write sub-function for state-dependend sampling to use with sapply
  fnMCStep <- function(state){
    return(sample(1:nStates, 1, prob = P[state, ]))
  }
  
  # Simulate markov chains
  for (i in 2:T){
    matSteps[, i] <- sapply(matSteps[, i-1], fnMCStep)
  }
  
  # Get steps needed to reach state x the first time for each simulation
  # Again, we use a sub-function that can be used with apply
  fnFirstTime <- function(mc){
    # Args:
    #   mc: markov chain (vector)
    
    return(which(mc == x)[1])  # returns NA, if state x is not reached at all
  }
  
  mean <- mean(apply(matSteps, 1, fnFirstTime), na.rm = TRUE)
  
  # Return mean
  return(mean)
}
```


# Poisson-Prozess

```{r Read Data}
N <- as.matrix(read.csv("data/traffic.csv", header = TRUE))

# Get vector of 96 data points
Nt <- as.vector(t(N[,2:5]))

# Calculate lambda tilde and lambda as function of t
lambdaTildeT <- Nt
lambdaT <- 1.2 * lambdaTildeT
```

```{r Simulate Poisson Traffic}
fnSimulatePoisson <- function(lambda, n) {
  # This function simulates poisson values based on vector of parameters lambda
  # 
  # Args:
  #   lambda:   Vector of parameters for poisson distribution
  #   n:        Number of simulations
  #   
  # Returns:
  #   Simulated vectors as matrix, where every row is a simulation of one day
  #   therefore the matrix as n rows.
  
  # Get random poisson distributed values for n days
  vSimulated <- rpois(length(lambda)*n, lambda)
  
  # Split data into matrix of form: mSplitted[day, quarter-hour]
  # where day goes from 1 to n and quater-hour from 1 to 96
  mSplitted <- t(matrix(vSimulated, nrow=length(lambda), ncol=n))
  
  return(mSplitted)
}

# Define number of simulations
nSimulations = 10000

# Run poisson simulation, based on parameter values from traffic.csv
mSimulation <- fnSimulatePoisson(lambdaT, nSimulations)
```

```{r Evaluate Results}
## Task 1
meanCarsPerDay <- mean(rowSums(mSimulation))

## Task 2
thousandsCar <- NULL
for(i in 1:nSimulations) {
  # Calculate cumulative sums per day (per simulation)
  cumsumDay <- cumsum(mSimulation[i,])
  
  # It's not clear if floor should ne applies only for mean, or also here
  # However, in the end the results seems to be the same
  thousandsCar[i] <- floor(max(which(cumsumDay <= 1000))/4)
}

meanThousandsCar <- floor(mean(thousandsCar))

## Task 3
# Time between 1:30 and 1:45 is at position 7
meanCarsAtNightQuarter <- mean(as.vector(mSimulation[,7]))
# The result is 0, which we can easily explain as lambda is 0 in this timeslot
# More input data, to have a more precise model, would possibly change this

## Task 4/5
maxTrafficPeriodIndices <- NULL
maxTrafficPeriodValues <- NULL
for(i in 1:nSimulations) {
  # Calculate cumulative sums per day (per simulation)
  cumsumDay <- cumsum(mSimulation[i,])
  
  # Initialize new vector
  sumHourlyPeriod <- NULL
  
  # Run from 0.0 to 23.0
  for(j in 1:(length(cumsumDay)-4)) {
    sumHourlyPeriod[j] <- cumsumDay[j+4] - cumsumDay[j]
  }
  
  # Get maximum position and store in vector
  maxTrafficPeriodIndices[i] <- which.max(sumHourlyPeriod)
  maxTrafficPeriodValues[i] <- max(sumHourlyPeriod)
}

par(mfrow = c(1,2))

hist(maxTrafficPeriodIndices,
     breaks = max(maxTrafficPeriodIndices)-min(maxTrafficPeriodIndices),
     main = paste("4) Histogramm bzgl. ", nSimulations, "Simulationen"),
     xlab = "Einstündige Periode mit maximalem Traffic", ylab = "Häufigkeit")
grid()
# where eg. 30 is the time period between 07:15 - 08:15,
# 31 is 07:30 - 08:30, and so on

hist(maxTrafficPeriodValues,
     main = paste("5) Histogramm bzgl. ", nSimulations, "Simulationen"),
     xlab = paste("Anzahl der vorbeifahrende Fahrzeuge in einstündiger Periode",
                  "mit maximalem Traffic"),
     ylab = "Häufigkeit")
grid()
```

# Der betrunkene Vogel

In dieser Aufgabe beschäftigen wir uns mit dem Unterschied in State Recurrence zwischen zwei- und dreidimensionalen Random Walks.
Anders gesagt: Ein betrunkener Mensch (d=2) findet meist nach Hause, ein betrunkener Vogel (d=3) aber vielleicht nicht.

Dazu betrachten wir eine brownsche Bewegung $B_t$, die vom Punkt x ausgeht...

```{r illustrate drunk bird and human}
# TODO: only use positive values on z-axis?
# TODO: find a good way to make the 3d line plot for the bird
# TODO: this could be way more efficient, right now we
# create a dataframe for each random walk (necessary for first plots, but not for MC)

# check if library is there
require('ggplot2')

fnRandomWalk <- function(d, x, N, R) {
  # This function generates a random walk of dimension d
  #
  #
  dfWalk = data.frame(matrix(nrow=N, ncol=d+1))
  
  n=1
  pos=x
  dfWalk[1,1:d] = pos
  dist = sqrt(sum(pos*pos))
  dfWalk[1,d+1] = dist
  
  while(n<N && R<dist) {
    # Thi is the loop handling the random walk
    rstep <- c(round(rnorm(d),2))
    pos = pos+rstep
    dist <- sqrt(sum(pos*pos))
    dfWalk[n+1,1:d] = pos+rstep
    dfWalk[n+1,d+1] = dist
    n = n+1 
  }
  # na.omit ist necessary to handle random walks exiting after n<N (made it home)
  return(na.omit(dfWalk))
}

set.seed(2567)
humanWalk <- fnRandomWalk(2, c(10,10), 1000, 3)
birdWalk <- fnRandomWalk(3, c(10,10,10), 1000, 3)
```

## Plots für Menschen und Vogel

Mensch und Vogel besuchen die gleiche Kneipe (die des Vogels liegt auf dem Dach der Bar), und torkeln nach getanem Werk nach Hause:

```{r human walk, echo=FALSE}
# Plotting human random walk
start <- data.frame(X=10, Y=10, Z=10)
goal <- data.frame(X=0, Y=0, Z=10)
p1 <- ggplot(humanWalk, aes(x=X1, y=X2, color=X3)) +
    geom_path() +
    geom_point(data=start,aes(X,Y),colour='red',size=4) +
    geom_point(data=goal,aes(X,Y),colour='green',size=4)
p1
```

Der Mensch muss sich nur in $R²$ bewegen...

```{r bird walk, echo=FALSE}
# Plotting bird random walk
birdWalk <- fnRandomWalk(3, c(10,10,10), 1000, 3)
p2 <- ggplot(birdWalk, aes(x=X1, y=X2, color=X4)) +
    geom_path() +
    geom_point(data=start,aes(X,Y),colour='red',size=4) +
    geom_point(data=goal,aes(X,Y),colour='green',size=4)
p2

```

während der Vogel in $R³$ Probleme bekommt.


## Monte Carlo

Jetzt simulieren wir den random walk für d=2 und d=3 mit einer Monte Carlo Simulation
```{r Simulate random walks}

fnRandomWalkMC <- function(nSim, nSamples, R) {
  # This is the MC wrapper function for the random walk simulation
  #
  #
  
  dfRand <- data.frame(matrix(nrow=length(nSim), ncol=3))
  for (i in 1:length(nSim)) {
    dfH <- NULL
    dfB <- NULL
    for (j in 1:nSamples) {
      dfH[j] <- dim(fnRandomWalk(2, startpos[1:2], nSim[i], R))[[1]]
      dfB[j] <- dim(fnRandomWalk(3, startpos[1:3], nSim[i], R))[[1]]
    }
    dfRand[i,] <- c(nSim[i], sum(dfH<nSim[i])/nSamples, sum(dfB<nSim[i])/nSamples)
    
  }
  return(dfRand)
}

# simulate
#################################### Runtime for this is about 60 sec.
ptbegin <- proc.time()
startpos <- c(10,10,10)
nSim <- c(10, 50, 100, 200, 500, 1000)#, 2000, 5000, 10000)
dfMC <- fnRandomWalkMC(nSim, 100, 3)
ptend <- proc.time() - ptbegin
####################################
```

```{r plot MC, echo=FALSE}
plotMC <- ggplot(dfMC, aes(x=X1, y=X2, color='human')) +
        geom_line() +
        geom_line(aes(x=X1, y=X3, color='bird')) +
        scale_x_log10()
plotMC
  
```

Die y-Achse zeigt den %-Anteil an random walks, die nach Hause führen. Die x-Achse zeigt die Anzahl der erlaubten Schritte (logarithmisch)

# Geometrische Brownsche Bewegung und Option Pricing

test
```{r}
#test
```




<!--Footnotes-->